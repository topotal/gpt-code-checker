[
  {
    filePath: 'getRepositoryContents.ts',
    content: 'import * as fs from "fs";\n' +
      'import * as path from "path";\n' +
      'import { minimatch } from "minimatch";\n' +
      '\n' +
      'async function getIgnoreList(ignoreFilePath: string): Promise<string[]> {\n' +
      '  let ignoreList: string[] = [];\n' +
      '\n' +
      '  try {\n' +
      '    const data = await fs.promises.readFile(ignoreFilePath, "utf-8");\n' +
      '    const lines = data.split(/\\r?\\n/);\n' +
      '\n' +
      '    for (let line of lines) {\n' +
      '      line = line.trim().replace(/\\\\/g, "/");\n' +
      '      if (line) {\n' +
      '        ignoreList.push(line);\n' +
      '      }\n' +
      '    }\n' +
      '  } catch (error) {\n' +
      '    // エラー処理（必要に応じて追加）\n' +
      '  }\n' +
      '  return ignoreList;\n' +
      '}\n' +
      '\n' +
      'function shouldIgnore(filePath: string, ignoreList: string[]): boolean {\n' +
      '  const normalizedFilePath = filePath.split(path.sep).join("/");\n' +
      '  for (const pattern of ignoreList) {\n' +
      '    if (minimatch(normalizedFilePath, pattern)) {\n' +
      '      return true;\n' +
      '    }\n' +
      '  }\n' +
      '  return false;\n' +
      '}\n' +
      '\n' +
      'export interface FileContent {\n' +
      '  filePath: string;\n' +
      '  content: string;\n' +
      '}\n' +
      '\n' +
      'export async function getRepositoryContents(repoPath: string): Promise<FileContent[]> {\n' +
      '  const fileContents: FileContent[] = [];\n' +
      '\n' +
      '  let ignoreFilePath = path.join(repoPath, ".gptignore");\n' +
      '\n' +
      '  let ignoreList: string[] = [];\n' +
      '  try {\n' +
      '    await fs.promises.access(ignoreFilePath, fs.constants.F_OK);\n' +
      '    ignoreList = await getIgnoreList(ignoreFilePath);\n' +
      '  } catch {\n' +
      '    const here = path.dirname(__filename);\n' +
      '    ignoreFilePath = path.join(here, ".gptignore");\n' +
      '    try {\n' +
      '      await fs.promises.access(ignoreFilePath, fs.constants.F_OK);\n' +
      '      ignoreList = await getIgnoreList(ignoreFilePath);\n' +
      '    } catch {\n' +
      '      ignoreList = [];\n' +
      '    }\n' +
      '  }\n' +
      '\n' +
      '  async function walkDirectory(currentPath: string) {\n' +
      '    const entries = await fs.promises.readdir(currentPath, {\n' +
      '      withFileTypes: true,\n' +
      '    });\n' +
      '    for (const entry of entries) {\n' +
      '      const fullPath = path.join(currentPath, entry.name);\n' +
      '      const relativeFilePath = path.relative(repoPath, fullPath).split(path.sep).join("/");\n' +
      '\n' +
      '      if (shouldIgnore(relativeFilePath, ignoreList)) {\n' +
      '        continue;\n' +
      '      }\n' +
      '\n' +
      '      if (entry.isDirectory()) {\n' +
      '        await walkDirectory(fullPath);\n' +
      '      } else if (entry.isFile()) {\n' +
      '        try {\n' +
      '          const contentsBuffer = await fs.promises.readFile(fullPath);\n' +
      '          const contents = contentsBuffer.toString("utf8");\n' +
      '          fileContents.push({\n' +
      '            filePath: relativeFilePath,\n' +
      '            content: contents,\n' +
      '          });\n' +
      '        } catch (error) {\n' +
      '          // エラー処理（必要に応じて追加）\n' +
      '        }\n' +
      '      }\n' +
      '    }\n' +
      '  }\n' +
      '\n' +
      '  await walkDirectory(repoPath);\n' +
      '\n' +
      '  return fileContents;\n' +
      '}\n'
  },
  {
    filePath: 'main.ts',
    content: 'import { getRepositoryContents } from "./getRepositoryContents";\n' +
      '\n' +
      'async function main() {\n' +
      '  const repoPath = "./";\n' +
      '  const repositoryContents = await getRepositoryContents(repoPath);\n' +
      '\n' +
      '  // 取得したリポジトリの内容をコンソールに出力\n' +
      '  console.log(repositoryContents);\n' +
      '\n' +
      '  // あるいは、AIへのコンテキストとして使用\n' +
      '  // ai.process(repositoryContents);\n' +
      '}\n' +
      '\n' +
      'main();\n'
  },
  {
    filePath: 'package.json',
    content: '{\n' +
      '  "name": "gpt-code-checker",\n' +
      '  "version": "1.0.0",\n' +
      '  "main": "index.js",\n' +
      '  "license": "MIT",\n' +
      '  "devDependencies": {\n' +
      '    "@types/minimatch": "^5.1.2",\n' +
      '    "@types/node": "^22.9.0",\n' +
      '    "minimatch": "^10.0.1",\n' +
      '    "typescript": "^5.6.3"\n' +
      '  },\n' +
      '  "dependencies": {\n' +
      '    "ts-node": "^10.9.2"\n' +
      '  }\n' +
      '}\n'
  },
  {
    filePath: 'tsconfig.json',
    content: '{\n' +
      '  "compilerOptions": {\n' +
      '    "target": "ES2020",\n' +
      '    "module": "CommonJS",\n' +
      '    "outDir": "dist",\n' +
      '    "strict": true,\n' +
      '    "esModuleInterop": true,\n' +
      '    "moduleResolution": "node",\n' +
      '    "forceConsistentCasingInFileNames": true,\n' +
      '    "types": ["node"]\n' +
      '  },\n' +
      '  "include": ["**/*.ts"],\n' +
      '  "exclude": ["node_modules"]\n' +
      '}\n'
  }
]
